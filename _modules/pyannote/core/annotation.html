

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyannote.core.annotation &mdash; pyannote.core 4.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> pyannote.core
          

          
          </a>

          
            
            
              <div class="version">
                4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../structure.html">Available data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../serialization.html">Serialization</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyannote.core</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyannote.core.annotation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyannote.core.annotation</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># encoding: utf-8</span>

<span class="c1"># The MIT License (MIT)</span>

<span class="c1"># Copyright (c) 2014-2020 CNRS</span>

<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>

<span class="c1"># The above copyright notice and this permission notice shall be included in</span>
<span class="c1"># all copies or substantial portions of the Software.</span>

<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>

<span class="c1"># AUTHORS</span>
<span class="c1"># Herv√© BREDIN - http://herve.niderb.fr</span>
<span class="c1"># Paul LERNER</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">##########</span>
<span class="sd">Annotation</span>
<span class="sd">##########</span>

<span class="sd">.. plot:: pyplots/annotation.py</span>

<span class="sd">:class:`pyannote.core.Annotation` instances are ordered sets of non-empty</span>
<span class="sd">tracks:</span>

<span class="sd">  - ordered, because segments are sorted by start time (and end time in case of tie)</span>
<span class="sd">  - set, because one cannot add twice the same track</span>
<span class="sd">  - non-empty, because one cannot add empty track</span>

<span class="sd">A track is a (support, name) pair where `support` is a Segment instance,</span>
<span class="sd">and `name` is an additional identifier so that it is possible to add multiple</span>
<span class="sd">tracks with the same support.</span>

<span class="sd">To define the annotation depicted above:</span>

<span class="sd">.. code-block:: ipython</span>

<span class="sd">    In [1]: from pyannote.core import Annotation, Segment</span>

<span class="sd">    In [6]: annotation = Annotation()</span>
<span class="sd">       ...: annotation[Segment(1, 5)] = &#39;Carol&#39;</span>
<span class="sd">       ...: annotation[Segment(6, 8)] = &#39;Bob&#39;</span>
<span class="sd">       ...: annotation[Segment(12, 18)] = &#39;Carol&#39;</span>
<span class="sd">       ...: annotation[Segment(7, 20)] = &#39;Alice&#39;</span>
<span class="sd">       ...:</span>

<span class="sd">which is actually a shortcut for</span>

<span class="sd">.. code-block:: ipython</span>

<span class="sd">    In [6]: annotation = Annotation()</span>
<span class="sd">       ...: annotation[Segment(1, 5), &#39;_&#39;] = &#39;Carol&#39;</span>
<span class="sd">       ...: annotation[Segment(6, 8), &#39;_&#39;] = &#39;Bob&#39;</span>
<span class="sd">       ...: annotation[Segment(12, 18), &#39;_&#39;] = &#39;Carol&#39;</span>
<span class="sd">       ...: annotation[Segment(7, 20), &#39;_&#39;] = &#39;Alice&#39;</span>
<span class="sd">       ...:</span>

<span class="sd">where all tracks share the same (default) name ``&#39;_&#39;``.</span>

<span class="sd">In case two tracks share the same support, use a different track name:</span>

<span class="sd">.. code-block:: ipython</span>

<span class="sd">    In [6]: annotation = Annotation(uri=&#39;my_video_file&#39;, modality=&#39;speaker&#39;)</span>
<span class="sd">       ...: annotation[Segment(1, 5), 1] = &#39;Carol&#39;  # track name = 1</span>
<span class="sd">       ...: annotation[Segment(1, 5), 2] = &#39;Bob&#39;    # track name = 2</span>
<span class="sd">       ...: annotation[Segment(12, 18)] = &#39;Carol&#39;</span>
<span class="sd">       ...:</span>

<span class="sd">The track name does not have to be unique over the whole set of tracks.</span>

<span class="sd">.. note::</span>

<span class="sd">  The optional *uri* and *modality* keywords argument can be used to remember</span>
<span class="sd">  which document and modality (e.g. speaker or face) it describes.</span>

<span class="sd">Several convenient methods are available. Here are a few examples:</span>

<span class="sd">.. code-block:: ipython</span>

<span class="sd">  In [9]: annotation.labels()   # sorted list of labels</span>
<span class="sd">  Out[9]: [&#39;Bob&#39;, &#39;Carol&#39;]</span>

<span class="sd">  In [10]: annotation.chart()   # label duration chart</span>
<span class="sd">  Out[10]: [(&#39;Carol&#39;, 10), (&#39;Bob&#39;, 4)]</span>

<span class="sd">  In [11]: list(annotation.itertracks())</span>
<span class="sd">  Out[11]: [(&lt;Segment(1, 5)&gt;, 1), (&lt;Segment(1, 5)&gt;, 2), (&lt;Segment(12, 18)&gt;, u&#39;_&#39;)]</span>

<span class="sd">  In [12]: annotation.label_timeline(&#39;Carol&#39;)</span>
<span class="sd">  Out[12]: &lt;Timeline(uri=my_video_file, segments=[&lt;Segment(1, 5)&gt;, &lt;Segment(12, 18)&gt;])&gt;</span>

<span class="sd">See :class:`pyannote.core.Annotation` for the complete reference.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">TextIO</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Text</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedDict</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">PYANNOTE_URI</span><span class="p">,</span> <span class="n">PYANNOTE_MODALITY</span><span class="p">,</span> \
    <span class="n">PYANNOTE_SEGMENT</span><span class="p">,</span> <span class="n">PYANNOTE_TRACK</span><span class="p">,</span> <span class="n">PYANNOTE_LABEL</span>
<span class="kn">from</span> <span class="nn">.json</span> <span class="kn">import</span> <span class="n">PYANNOTE_JSON</span><span class="p">,</span> <span class="n">PYANNOTE_JSON_CONTENT</span>
<span class="kn">from</span> <span class="nn">.segment</span> <span class="kn">import</span> <span class="n">Segment</span>
<span class="kn">from</span> <span class="nn">.timeline</span> <span class="kn">import</span> <span class="n">Timeline</span>
<span class="kn">from</span> <span class="nn">.utils.generators</span> <span class="kn">import</span> <span class="n">string_generator</span><span class="p">,</span> <span class="n">int_generator</span>
<span class="kn">from</span> <span class="nn">.utils.types</span> <span class="kn">import</span> <span class="n">Label</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Support</span><span class="p">,</span> <span class="n">LabelGenerator</span><span class="p">,</span> <span class="n">TrackName</span><span class="p">,</span> <span class="n">CropMode</span>


<div class="viewcode-block" id="Annotation"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation">[docs]</a><span class="k">class</span> <span class="nc">Annotation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Annotation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uri : string, optional</span>
<span class="sd">        name of annotated resource (e.g. audio or video file)</span>
<span class="sd">    modality : string, optional</span>
<span class="sd">        name of annotated modality</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    annotation : Annotation</span>
<span class="sd">        New annotation</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_df</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                <span class="n">uri</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">modality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">PYANNOTE_SEGMENT</span><span class="p">,</span> <span class="n">PYANNOTE_TRACK</span><span class="p">,</span> <span class="n">PYANNOTE_LABEL</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">Annotation</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="p">)</span>

<div class="viewcode-block" id="Annotation.__init__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uri</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">modality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_uri</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">uri</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">modality</span>

        <span class="c1"># sorted dictionary</span>
        <span class="c1"># keys: annotated segments</span>
        <span class="c1"># values: {track: label} dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TrackName</span><span class="p">,</span> <span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span>

        <span class="c1"># dictionary</span>
        <span class="c1"># key: label</span>
        <span class="c1"># value: timeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="n">Timeline</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">:</span> <span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># timeline meant to store all annotated segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeline</span><span class="p">:</span> <span class="n">Timeline</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uri</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uri</span>

    <span class="nd">@uri</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">uri</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uri</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># update uri for all internal timelines</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>
            <span class="n">timeline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_timeline</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">timeline</span><span class="o">.</span><span class="n">uri</span> <span class="o">=</span> <span class="n">uri</span>
        <span class="n">timeline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">timeline</span><span class="o">.</span><span class="n">uri</span> <span class="o">=</span> <span class="n">uri</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uri</span> <span class="o">=</span> <span class="n">uri</span>

    <span class="k">def</span> <span class="nf">_updateLabels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># list of labels that needs to be updated</span>
        <span class="n">update</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">label</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">update</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">update</span><span class="p">)</span>

        <span class="c1"># accumulate segments for updated labels</span>
        <span class="n">_segments</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">update</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">_segments</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>

        <span class="c1"># create timeline with accumulated segments for updated labels</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">update</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_segments</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span>
                    <span class="n">segments</span><span class="o">=</span><span class="n">_segments</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Annotation.__len__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of segments</span>

<span class="sd">        &gt;&gt;&gt; len(annotation)  # annotation contains three segments</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__bool__</span><span class="p">()</span>

<div class="viewcode-block" id="Annotation.__bool__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__bool__">[docs]</a>    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Emptiness</span>

<span class="sd">        &gt;&gt;&gt; if annotation:</span>
<span class="sd">        ...    # annotation is empty</span>
<span class="sd">        ... else:</span>
<span class="sd">        ...    # annotation is not empty</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Annotation.itersegments"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.itersegments">[docs]</a>    <span class="k">def</span> <span class="nf">itersegments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over segments (in chronological order)</span>

<span class="sd">        &gt;&gt;&gt; for segment in annotation.itersegments():</span>
<span class="sd">        ...     # do something with the segment</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`pyannote.core.Segment` describes how segments are sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.itertracks"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.itertracks">[docs]</a>    <span class="k">def</span> <span class="nf">itertracks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yield_label</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span>
                             <span class="n">Tuple</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">TrackName</span><span class="p">],</span>
                             <span class="n">Tuple</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">TrackName</span><span class="p">,</span> <span class="n">Label</span><span class="p">]</span>
                         <span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Iterate over tracks (in chronological order)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        yield_label : bool, optional</span>
<span class="sd">            When True, yield (segment, track, label) tuples, such that</span>
<span class="sd">            annotation[segment, track] == label. Defaults to yielding</span>
<span class="sd">            (segment, track) tuple.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; for segment, track in annotation.itertracks():</span>
<span class="sd">        ...     # do something with the track</span>

<span class="sd">        &gt;&gt;&gt; for segment, track, label in annotation.itertracks(yield_label=True):</span>
<span class="sd">        ...     # do something with the track and its label</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">tracks</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">track</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                                     <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tl</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">1</span><span class="p">]))):</span>
                <span class="k">if</span> <span class="n">yield_label</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">lbl</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span></div>

    <span class="k">def</span> <span class="nf">_updateTimeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeline</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">,</span> <span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Annotation.get_timeline"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.get_timeline">[docs]</a>    <span class="k">def</span> <span class="nf">get_timeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timeline</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get timeline made of all annotated segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            Defaults (True) to returning a copy of the internal timeline.</span>
<span class="sd">            Set to False to return the actual internal timeline (faster).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timeline : Timeline</span>
<span class="sd">            Timeline made of all annotated segments.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        In case copy is set to False, be careful **not** to modify the returned</span>
<span class="sd">        timeline, as it may lead to weird subsequent behavior of the annotation</span>
<span class="sd">        instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateTimeline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeline</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeline</span></div>

<div class="viewcode-block" id="Annotation.__eq__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equality</span>

<span class="sd">        &gt;&gt;&gt; annotation == other</span>

<span class="sd">        Two annotations are equal if and only if their tracks and associated</span>
<span class="sd">        labels are equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pairOfTracks</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">other</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">pairOfTracks</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.__ne__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__ne__">[docs]</a>    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inequality&quot;&quot;&quot;</span>
        <span class="n">pairOfTracks</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">other</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">t1</span> <span class="o">!=</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">pairOfTracks</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.__contains__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">included</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">Timeline</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inclusion</span>

<span class="sd">        Check whether every segment of `included` does exist in annotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        included : Segment or Timeline</span>
<span class="sd">            Segment or timeline being checked for inclusion</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contains : bool</span>
<span class="sd">            True if every segment in `included` exists in timeline,</span>
<span class="sd">            False otherwise</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">included</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.write_rttm"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.write_rttm">[docs]</a>    <span class="k">def</span> <span class="nf">write_rttm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="n">TextIO</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dump annotation to file using RTTM format</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : file object</span>

<span class="sd">        Usage</span>
<span class="sd">        -----</span>
<span class="sd">        &gt;&gt;&gt; with open(&#39;file.rttm&#39;, &#39;w&#39;) as file:</span>
<span class="sd">        ...     annotation.write_rttm(file)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">uri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uri</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uri</span> <span class="k">else</span> <span class="s2">&quot;&lt;NA&gt;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">Text</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">uri</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Space-separated RTTM file format does not allow file URIs &#39;</span>
                   <span class="sa">f</span><span class="s1">&#39;containing spaces (got: &quot;</span><span class="si">{</span><span class="n">uri</span><span class="si">}</span><span class="s1">&quot;).&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Text</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Space-separated RTTM file format does not allow labels &#39;</span>
                       <span class="sa">f</span><span class="s1">&#39;containing spaces (got: &quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&quot;).&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;SPEAKER </span><span class="si">{</span><span class="n">uri</span><span class="si">}</span><span class="s1"> 1 </span><span class="si">{</span><span class="n">segment</span><span class="o">.</span><span class="n">start</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">segment</span><span class="o">.</span><span class="n">duration</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;&lt;NA&gt; &lt;NA&gt; </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> &lt;NA&gt; &lt;NA&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.crop"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.crop">[docs]</a>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">support</span><span class="p">:</span> <span class="n">Support</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">CropMode</span> <span class="o">=</span> <span class="s1">&#39;intersection&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop annotation to new support</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        support : Segment or Timeline</span>
<span class="sd">            If `support` is a `Timeline`, its support is used.</span>
<span class="sd">        mode : {&#39;strict&#39;, &#39;loose&#39;, &#39;intersection&#39;}, optional</span>
<span class="sd">            Controls how segments that are not fully included in `support` are</span>
<span class="sd">            handled. &#39;strict&#39; mode only keeps fully included segments. &#39;loose&#39;</span>
<span class="sd">            mode keeps any intersecting segment. &#39;intersection&#39; mode keeps any</span>
<span class="sd">            intersecting segment but replace them by their actual intersection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cropped : Annotation</span>
<span class="sd">            Cropped annotation</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        In &#39;intersection&#39; mode, the best is done to keep the track names</span>
<span class="sd">        unchanged. However, in some cases where two original segments are</span>
<span class="sd">        cropped into the same resulting segments, conflicting track names are</span>
<span class="sd">        modified to make sure no track is lost.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO speed things up by working directly with annotation internals</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">support</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="n">support</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">[</span><span class="n">support</span><span class="p">],</span> <span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">support</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">support</span><span class="p">,</span> <span class="n">Timeline</span><span class="p">):</span>

            <span class="c1"># if &#39;support&#39; is a `Timeline`, we use its support</span>
            <span class="n">support</span> <span class="o">=</span> <span class="n">support</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
            <span class="n">cropped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;loose&#39;</span><span class="p">:</span>

                <span class="n">_tracks</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

                <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">co_iter</span><span class="p">(</span><span class="n">support</span><span class="p">):</span>
                    <span class="n">tracks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">])</span>
                    <span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">tracks</span>
                    <span class="n">_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="n">cropped</span><span class="o">.</span><span class="n">_tracks</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">(</span><span class="n">_tracks</span><span class="p">)</span>

                <span class="n">cropped</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>
                <span class="n">cropped</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>

                <span class="n">cropped</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">cropped</span><span class="o">.</span><span class="n">_timeline</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">return</span> <span class="n">cropped</span>

            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;strict&#39;</span><span class="p">:</span>

                <span class="n">_tracks</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

                <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">other_segment</span> <span class="ow">in</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">co_iter</span><span class="p">(</span><span class="n">support</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">segment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other_segment</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">tracks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">])</span>
                    <span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">tracks</span>
                    <span class="n">_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="n">cropped</span><span class="o">.</span><span class="n">_tracks</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">(</span><span class="n">_tracks</span><span class="p">)</span>

                <span class="n">cropped</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>
                <span class="n">cropped</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>

                <span class="n">cropped</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">cropped</span><span class="o">.</span><span class="n">_timeline</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">return</span> <span class="n">cropped</span>

            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;intersection&#39;</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">other_segment</span> <span class="ow">in</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">co_iter</span><span class="p">(</span><span class="n">support</span><span class="p">):</span>

                    <span class="n">intersection</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">&amp;</span> <span class="n">other_segment</span>
                    <span class="k">for</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">track</span> <span class="o">=</span> <span class="n">cropped</span><span class="o">.</span><span class="n">new_track</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span>
                                                  <span class="n">candidate</span><span class="o">=</span><span class="n">track</span><span class="p">)</span>
                        <span class="n">cropped</span><span class="p">[</span><span class="n">intersection</span><span class="p">,</span> <span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

                <span class="k">return</span> <span class="n">cropped</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;unsupported mode: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.get_tracks"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.get_tracks">[docs]</a>    <span class="k">def</span> <span class="nf">get_tracks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="n">Segment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">TrackName</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Query tracks by segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : Segment</span>
<span class="sd">            Query</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tracks : set</span>
<span class="sd">            Set of tracks</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This will return an empty set if segment does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="Annotation.has_track"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.has_track">[docs]</a>    <span class="k">def</span> <span class="nf">has_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">track</span><span class="p">:</span> <span class="n">TrackName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check whether a given track exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : Segment</span>
<span class="sd">            Query segment</span>
<span class="sd">        track :</span>
<span class="sd">            Query track</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exists : bool</span>
<span class="sd">            True if track exists for segment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">track</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">{})</span></div>

<div class="viewcode-block" id="Annotation.copy"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the annotation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotation : Annotation</span>
<span class="sd">            Copy of the annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create new empty annotation</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">)</span>

        <span class="c1"># deep copy internal track dictionary</span>
        <span class="n">_tracks</span><span class="p">,</span> <span class="n">_labels</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

        <span class="n">copied</span><span class="o">.</span><span class="n">_tracks</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">(</span><span class="n">_tracks</span><span class="p">)</span>

        <span class="n">copied</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>

        <span class="n">copied</span><span class="o">.</span><span class="n">_timeline</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">copied</span></div>

<div class="viewcode-block" id="Annotation.new_track"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.new_track">[docs]</a>    <span class="k">def</span> <span class="nf">new_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="n">Segment</span><span class="p">,</span>
                  <span class="n">candidate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TrackName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrackName</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate a new track name for given segment</span>

<span class="sd">        Ensures that the returned track name does not already</span>
<span class="sd">        exist for the given segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : Segment</span>
<span class="sd">            Segment for which a new track name is generated.</span>
<span class="sd">        candidate : any valid track name, optional</span>
<span class="sd">            When provided, try this candidate name first.</span>
<span class="sd">        prefix : str, optional</span>
<span class="sd">            Track name prefix. Defaults to the empty string &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name : str</span>
<span class="sd">            New track name</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># obtain list of existing tracks for segment</span>
        <span class="n">existing_tracks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="c1"># if candidate is provided, check whether it already exists</span>
        <span class="c1"># in case it does not, use it</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_tracks</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">candidate</span>

        <span class="c1"># no candidate was provided or the provided candidate already exists</span>
        <span class="c1"># we need to create a brand new one</span>

        <span class="c1"># by default (if prefix is not provided), use &#39;&#39;</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># find first non-existing track name for segment</span>
        <span class="c1"># eg. if &#39;0&#39; exists, try &#39;1&#39;, then &#39;2&#39;, ...</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="ow">in</span> <span class="n">existing_tracks</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># return first non-existing track name</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.__str__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human-friendly representation&quot;&quot;&quot;</span>
        <span class="c1"># TODO: use pandas.DataFrame</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span></div>

<div class="viewcode-block" id="Annotation.__delitem__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__delitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete one track</span>

<span class="sd">        &gt;&gt;&gt; del annotation[segment, track]</span>

<span class="sd">        Delete all tracks of a segment</span>

<span class="sd">        &gt;&gt;&gt; del annotation[segment]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># del annotation[segment]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>

            <span class="c1"># Pop segment out of dictionary</span>
            <span class="c1"># and get corresponding tracks</span>
            <span class="c1"># Raises KeyError if segment does not exist</span>
            <span class="n">tracks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="c1"># mark timeline as modified</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># mark every label in tracks as modified</span>
            <span class="k">for</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tracks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># del annotation[segment, track]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="c1"># get segment tracks as dictionary</span>
            <span class="c1"># if segment does not exist, get empty dictionary</span>
            <span class="c1"># Raises KeyError if segment does not exist</span>
            <span class="n">tracks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># pop track out of tracks dictionary</span>
            <span class="c1"># and get corresponding label</span>
            <span class="c1"># Raises KeyError if track does not exist</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">tracks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># mark label as modified</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># if tracks dictionary is now empty,</span>
            <span class="c1"># remove segment as well</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tracks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;Deletion only works with Segment or (Segment, track) keys.&#39;</span><span class="p">)</span></div>

    <span class="c1"># label = annotation[segment, track]</span>
<div class="viewcode-block" id="Annotation.__getitem__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Label</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get track label</span>

<span class="sd">        &gt;&gt;&gt; label = annotation[segment, track]</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        ``annotation[segment]`` is equivalent to ``annotation[segment, &#39;_&#39;]``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>

    <span class="c1"># annotation[segment, track] = label</span>
<div class="viewcode-block" id="Annotation.__setitem__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add new or update existing track</span>

<span class="sd">        &gt;&gt;&gt; annotation[segment, track] = label</span>

<span class="sd">        If (segment, track) does not exist, it is added.</span>
<span class="sd">        If (segment, track) already exists, it is updated.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        ``annotation[segment] = label`` is equivalent to ``annotation[segment, &#39;_&#39;] = label``</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If `segment` is empty, it does nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>

        <span class="n">segment</span><span class="p">,</span> <span class="n">track</span> <span class="o">=</span> <span class="n">key</span>

        <span class="c1"># do not add empty track</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">segment</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># in case we create a new segment</span>
        <span class="c1"># mark timeline as modified</span>
        <span class="k">if</span> <span class="n">segment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># in case we modify an existing track</span>
        <span class="c1"># mark old label as modified</span>
        <span class="k">if</span> <span class="n">track</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]:</span>
            <span class="n">old_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">][</span><span class="n">track</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">old_label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># mark new label as modified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">][</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Annotation.empty"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.empty">[docs]</a>    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return an empty copy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        empty : Annotation</span>
<span class="sd">            Empty annotation using the same &#39;uri&#39; and &#39;modality&#39; attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.labels"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.labels">[docs]</a>    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get sorted list of labels</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : list</span>
<span class="sd">            Sorted list of labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">lnu</span> <span class="k">for</span> <span class="n">lnu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateLabels</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.get_labels"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.get_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Query labels by segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : Segment</span>
<span class="sd">            Query</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">            When False, return the list of (possibly repeated) labels.</span>
<span class="sd">            Defaults to returning the set of labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : set</span>
<span class="sd">            Set of labels for `segment` if it exists, empty set otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; annotation = Annotation()</span>
<span class="sd">        &gt;&gt;&gt; segment = Segment(0, 2)</span>
<span class="sd">        &gt;&gt;&gt; annotation[segment, &#39;speaker1&#39;] = &#39;Bernard&#39;</span>
<span class="sd">        &gt;&gt;&gt; annotation[segment, &#39;speaker2&#39;] = &#39;John&#39;</span>
<span class="sd">        &gt;&gt;&gt; print sorted(annotation.get_labels(segment))</span>
<span class="sd">        set([&#39;Bernard&#39;, &#39;John&#39;])</span>
<span class="sd">        &gt;&gt;&gt; print annotation.get_labels(Segment(1, 2))</span>
<span class="sd">        set([])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Annotation.subset"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">],</span> <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter annotation by labels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : iterable</span>
<span class="sd">            List of filtered labels</span>
<span class="sd">        invert : bool, optional</span>
<span class="sd">            If invert is True, extract all but requested labels</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered : Annotation</span>
<span class="sd">            Filtered annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span> <span class="o">-</span> <span class="n">labels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span>

        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">)</span>

        <span class="n">_tracks</span><span class="p">,</span> <span class="n">_labels</span> <span class="o">=</span> <span class="p">{},</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">tracks</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sub_tracks</span> <span class="o">=</span> <span class="p">{</span><span class="n">track</span><span class="p">:</span> <span class="n">label</span> <span class="k">for</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tracks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">sub_tracks</span><span class="p">:</span>
                <span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_tracks</span>
                <span class="n">_labels</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sub_tracks</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">sub</span><span class="o">.</span><span class="n">_tracks</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">(</span><span class="n">_tracks</span><span class="p">)</span>

        <span class="n">sub</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>
        <span class="n">sub</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">_labels</span><span class="p">}</span>

        <span class="n">sub</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sub</span><span class="o">.</span><span class="n">_timeline</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">sub</span></div>

<div class="viewcode-block" id="Annotation.update"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add every track of an existing annotation (in place)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        annotation : Annotation</span>
<span class="sd">            Annotation whose tracks are being added</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            Return a copy of the annotation. Defaults to updating the</span>
<span class="sd">            annotation in-place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Annotation</span>
<span class="sd">            Updated annotation</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Existing tracks are updated with the new label.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="c1"># TODO speed things up by working directly with annotation internals</span>
        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Annotation.label_timeline"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.label_timeline">[docs]</a>    <span class="k">def</span> <span class="nf">label_timeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timeline</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Query segments by label</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            Query</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            Defaults (True) to returning a copy of the internal timeline.</span>
<span class="sd">            Set to False to return the actual internal timeline (faster).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timeline : Timeline</span>
<span class="sd">            Timeline made of all segments for which at least one track is</span>
<span class="sd">            annotated as label</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If label does not exist, this will return an empty timeline.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        In case copy is set to False, be careful **not** to modify the returned</span>
<span class="sd">        timeline, as it may lead to weird subsequent behavior of the annotation</span>
<span class="sd">        instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateLabels</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span></div>

<div class="viewcode-block" id="Annotation.label_support"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.label_support">[docs]</a>    <span class="k">def</span> <span class="nf">label_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timeline</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Label support</span>

<span class="sd">        Equivalent to ``Annotation.label_timeline(label).support()``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            Query</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        support : Timeline</span>
<span class="sd">            Label support</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~pyannote.core.Annotation.label_timeline`</span>
<span class="sd">        :func:`~pyannote.core.Timeline.support`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_timeline</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">support</span><span class="p">()</span></div>

<div class="viewcode-block" id="Annotation.label_duration"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.label_duration">[docs]</a>    <span class="k">def</span> <span class="nf">label_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Label duration</span>

<span class="sd">        Equivalent to ``Annotation.label_timeline(label).duration()``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            Query</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration, in seconds.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~pyannote.core.Annotation.label_timeline`</span>
<span class="sd">        :func:`~pyannote.core.Timeline.duration`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_timeline</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">duration</span><span class="p">()</span></div>

<div class="viewcode-block" id="Annotation.chart"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.chart">[docs]</a>    <span class="k">def</span> <span class="nf">chart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get labels chart (from longest to shortest duration)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percent : bool, optional</span>
<span class="sd">            Return list of (label, percentage) tuples.</span>
<span class="sd">            Defaults to returning list of (label, duration) tuples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chart : list</span>
<span class="sd">            List of (label, duration), sorted by duration in decreasing order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chart</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(((</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_duration</span><span class="p">(</span><span class="n">L</span><span class="p">))</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()),</span>
                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">percent</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">duration</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">duration</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">])</span>
            <span class="n">chart</span> <span class="o">=</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="n">duration</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">chart</span></div>

<div class="viewcode-block" id="Annotation.argmax"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">support</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Support</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get label with longest duration</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        support : Segment or Timeline, optional</span>
<span class="sd">            Find label with longest duration within provided support.</span>
<span class="sd">            Defaults to whole extent.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        label : any existing label or None</span>
<span class="sd">            Label with longest intersection</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; annotation = Annotation(modality=&#39;speaker&#39;)</span>
<span class="sd">        &gt;&gt;&gt; annotation[Segment(0, 10), &#39;speaker1&#39;] = &#39;Alice&#39;</span>
<span class="sd">        &gt;&gt;&gt; annotation[Segment(8, 20), &#39;speaker1&#39;] = &#39;Bob&#39;</span>
<span class="sd">        &gt;&gt;&gt; print &quot;%s is such a talker!&quot; % annotation.argmax()</span>
<span class="sd">        Bob is such a talker!</span>
<span class="sd">        &gt;&gt;&gt; segment = Segment(22, 23)</span>
<span class="sd">        &gt;&gt;&gt; if not annotation.argmax(support):</span>
<span class="sd">        ...    print &quot;No label intersecting %s&quot; % segment</span>
<span class="sd">        No label intersection [22 --&gt; 23]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cropped</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">support</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cropped</span> <span class="o">=</span> <span class="n">cropped</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">support</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cropped</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(((</span><span class="n">_</span><span class="p">,</span> <span class="n">cropped</span><span class="o">.</span><span class="n">label_duration</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">cropped</span><span class="o">.</span><span class="n">labels</span><span class="p">()),</span>
                   <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Annotation.rename_tracks"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.rename_tracks">[docs]</a>    <span class="k">def</span> <span class="nf">rename_tracks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">:</span> <span class="n">LabelGenerator</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rename all tracks</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        generator : &#39;string&#39;, &#39;int&#39;, or iterable, optional</span>
<span class="sd">            If &#39;string&#39; (default) rename tracks to &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, etc.</span>
<span class="sd">            If &#39;int&#39;, rename tracks to 0, 1, 2, etc.</span>
<span class="sd">            If iterable, use it to generate track names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Annotation</span>
<span class="sd">            Copy of the original annotation where tracks are renamed.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; annotation = Annotation()</span>
<span class="sd">        &gt;&gt;&gt; annotation[Segment(0, 1), &#39;a&#39;] = &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; annotation[Segment(0, 1), &#39;b&#39;] = &#39;b&#39;</span>
<span class="sd">        &gt;&gt;&gt; annotation[Segment(1, 2), &#39;a&#39;] = &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; annotation[Segment(1, 3), &#39;c&#39;] = &#39;c&#39;</span>
<span class="sd">        &gt;&gt;&gt; print(annotation)</span>
<span class="sd">        [ 00:00:00.000 --&gt;  00:00:01.000] a a</span>
<span class="sd">        [ 00:00:00.000 --&gt;  00:00:01.000] b b</span>
<span class="sd">        [ 00:00:01.000 --&gt;  00:00:02.000] a a</span>
<span class="sd">        [ 00:00:01.000 --&gt;  00:00:03.000] c c</span>
<span class="sd">        &gt;&gt;&gt; print(annotation.rename_tracks(generator=&#39;int&#39;))</span>
<span class="sd">        [ 00:00:00.000 --&gt;  00:00:01.000] 0 a</span>
<span class="sd">        [ 00:00:00.000 --&gt;  00:00:01.000] 1 b</span>
<span class="sd">        [ 00:00:01.000 --&gt;  00:00:02.000] 2 a</span>
<span class="sd">        [ 00:00:01.000 --&gt;  00:00:03.000] 3 c</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">renamed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">generator</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">string_generator</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">generator</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">int_generator</span><span class="p">()</span>

        <span class="c1"># TODO speed things up by working directly with annotation internals</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">renamed</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)]</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">return</span> <span class="n">renamed</span></div>

<div class="viewcode-block" id="Annotation.rename_labels"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.rename_labels">[docs]</a>    <span class="k">def</span> <span class="nf">rename_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">generator</span><span class="p">:</span> <span class="n">LabelGenerator</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
                      <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rename labels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping : dict, optional</span>
<span class="sd">            {old_name: new_name} mapping dictionary.</span>
<span class="sd">        generator : &#39;string&#39;, &#39;int&#39; or iterable, optional</span>
<span class="sd">            If &#39;string&#39; (default) rename label to &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... If &#39;int&#39;,</span>
<span class="sd">            rename to 0, 1, 2, etc. If iterable, use it to generate labels.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            Set to True to return a copy of the annotation. Set to False to</span>
<span class="sd">            update the annotation in-place. Defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Annotation</span>
<span class="sd">            Annotation where labels have been renamed</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Unmapped labels are kept unchanged.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Parameter `generator` has no effect when `mapping` is provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">generator</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
                <span class="n">generator</span> <span class="o">=</span> <span class="n">string_generator</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">generator</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
                <span class="n">generator</span> <span class="o">=</span> <span class="n">int_generator</span><span class="p">()</span>
            <span class="c1"># generate mapping</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()}</span>

        <span class="n">renamed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">old_label</span><span class="p">,</span> <span class="n">new_label</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">renamed</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">old_label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">renamed</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">tracks</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tracks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_tracks</span> <span class="o">=</span> <span class="p">{</span><span class="n">track</span><span class="p">:</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tracks</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">renamed</span><span class="o">.</span><span class="n">_tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_tracks</span>

        <span class="k">return</span> <span class="n">renamed</span></div>

<div class="viewcode-block" id="Annotation.relabel_tracks"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.relabel_tracks">[docs]</a>    <span class="k">def</span> <span class="nf">relabel_tracks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">:</span> <span class="n">LabelGenerator</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Relabel tracks</span>

<span class="sd">        Create a new annotation where each track has a unique label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        generator : &#39;string&#39;, &#39;int&#39; or iterable, optional</span>
<span class="sd">            If &#39;string&#39; (default) relabel tracks to &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... If &#39;int&#39;</span>
<span class="sd">            relabel to 0, 1, 2, ... If iterable, use it to generate labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Annotation</span>
<span class="sd">            New annotation with relabeled tracks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">generator</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">string_generator</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">generator</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">int_generator</span><span class="p">()</span>

        <span class="n">relabeled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">relabeled</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">relabeled</span></div>

<div class="viewcode-block" id="Annotation.support"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.support">[docs]</a>    <span class="k">def</span> <span class="nf">support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collar</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Annotation support</span>

<span class="sd">        The support of an annotation is an annotation where contiguous tracks</span>
<span class="sd">        with same label are merged into one unique covering track.</span>

<span class="sd">        A picture is worth a thousand words::</span>

<span class="sd">            collar</span>
<span class="sd">            |---|</span>

<span class="sd">            annotation</span>
<span class="sd">            |--A--| |--A--|     |-B-|</span>
<span class="sd">              |-B-|    |--C--|     |----B-----|</span>

<span class="sd">            annotation.support(collar)</span>
<span class="sd">            |------A------|     |------B------|</span>
<span class="sd">              |-B-|    |--C--|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        collar : float, optional</span>
<span class="sd">            Merge tracks with same label and separated by less than `collar`</span>
<span class="sd">            seconds. This is why &#39;A&#39; tracks are merged in above figure.</span>
<span class="sd">            Defaults to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        support : Annotation</span>
<span class="sd">            Annotation support</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Track names are lost in the process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">generator</span> <span class="o">=</span> <span class="n">string_generator</span><span class="p">()</span>

        <span class="c1"># initialize an empty annotation</span>
        <span class="c1"># with same uri and modality as original</span>
        <span class="n">support</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>

            <span class="c1"># get timeline for current label</span>
            <span class="n">timeline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_timeline</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># fill the gaps shorter than collar</span>
            <span class="n">timeline</span> <span class="o">=</span> <span class="n">timeline</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">collar</span><span class="p">)</span>

            <span class="c1"># reconstruct annotation with merged tracks</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">timeline</span><span class="o">.</span><span class="n">support</span><span class="p">():</span>
                <span class="n">support</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)]</span> <span class="o">=</span> <span class="n">label</span>

        <span class="k">return</span> <span class="n">support</span></div>

<div class="viewcode-block" id="Annotation.co_iter"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.co_iter">[docs]</a>    <span class="k">def</span> <span class="nf">co_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">TrackName</span><span class="p">],</span>
                              <span class="n">Tuple</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">TrackName</span><span class="p">]]</span>
            <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Iterate over pairs of intersecting tracks</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Annotation</span>
<span class="sd">            Second annotation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterable : (Segment, object), (Segment, object) iterable</span>
<span class="sd">            Yields pairs of intersecting tracks, in chronological (then</span>
<span class="sd">            alphabetical) order.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~pyannote.core.Timeline.co_iter`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timeline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">other_timeline</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_timeline</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">timeline</span><span class="o">.</span><span class="n">co_iter</span><span class="p">(</span><span class="n">other_timeline</span><span class="p">):</span>
            <span class="n">tracks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tracks</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">other_tracks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">get_tracks</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">tracks</span><span class="p">,</span> <span class="n">other_tracks</span><span class="p">):</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.__mul__"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Cooccurrence (or confusion) matrix</span>

<span class="sd">        &gt;&gt;&gt; matrix = annotation * other</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Annotation</span>
<span class="sd">            Second annotation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cooccurrence : (n_self, n_other) np.ndarray</span>
<span class="sd">            Cooccurrence matrix where `n_self` (resp. `n_other`) is the number</span>
<span class="sd">            of labels in `self` (resp. `other`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;computing cooccurrence matrix only works with Annotation &#39;</span>
                <span class="s1">&#39;instances.&#39;</span><span class="p">)</span>

        <span class="n">i_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
        <span class="n">j_labels</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>

        <span class="n">I</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_labels</span><span class="p">)}</span>
        <span class="n">J</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">j_labels</span><span class="p">)}</span>

        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">)))</span>

        <span class="c1"># iterate over intersecting tracks and accumulate durations</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">),</span> <span class="p">(</span><span class="n">other_segment</span><span class="p">,</span> <span class="n">other_track</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">co_iter</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">]]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">other</span><span class="p">[</span><span class="n">other_segment</span><span class="p">,</span> <span class="n">other_track</span><span class="p">]]</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span> <span class="o">&amp;</span> <span class="n">other_segment</span><span class="p">)</span><span class="o">.</span><span class="n">duration</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">duration</span>

        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="Annotation.for_json"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.for_json">[docs]</a>    <span class="k">def</span> <span class="nf">for_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Serialization</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :mod:`pyannote.core.json`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">PYANNOTE_JSON</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">}</span>
        <span class="n">content</span> <span class="o">=</span> <span class="p">[{</span><span class="n">PYANNOTE_SEGMENT</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">for_json</span><span class="p">(),</span>
                    <span class="n">PYANNOTE_TRACK</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span>
                    <span class="n">PYANNOTE_LABEL</span><span class="p">:</span> <span class="n">l</span><span class="p">}</span>
                   <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">PYANNOTE_JSON_CONTENT</span><span class="p">]</span> <span class="o">=</span> <span class="n">content</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uri</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">PYANNOTE_URI</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uri</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modality</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">PYANNOTE_MODALITY</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modality</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Annotation.from_json"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.from_json">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deserialization</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :mod:`pyannote.core.json`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uri</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">PYANNOTE_URI</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">modality</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">PYANNOTE_MODALITY</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">record_dict</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">PYANNOTE_JSON_CONTENT</span><span class="p">]:</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">record_dict</span><span class="p">[</span><span class="n">PYANNOTE_SEGMENT</span><span class="p">])</span>
            <span class="n">track</span> <span class="o">=</span> <span class="n">record_dict</span><span class="p">[</span><span class="n">PYANNOTE_TRACK</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">record_dict</span><span class="p">[</span><span class="n">PYANNOTE_LABEL</span><span class="p">]</span>
            <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Annotation</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.from_records"><a class="viewcode-back" href="../../../reference.html#pyannote.core.Annotation.from_records">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_records</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">records</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Segment</span><span class="p">,</span> <span class="n">TrackName</span><span class="p">,</span> <span class="n">Label</span><span class="p">]],</span>
                     <span class="n">uri</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">modality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Annotation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Annotation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        records : iterator of tuples</span>
<span class="sd">            (segment, track, label) tuples</span>
<span class="sd">        uri : string, optional</span>
<span class="sd">            name of annotated resource (e.g. audio or video file)</span>
<span class="sd">        modality : string, optional</span>
<span class="sd">            name of annotated modality</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotation : Annotation</span>
<span class="sd">            New annotation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="n">uri</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="n">modality</span><span class="p">)</span>
        <span class="n">tracks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
            <span class="n">tracks</span><span class="p">[</span><span class="n">segment</span><span class="p">][</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">_tracks</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">(</span><span class="n">tracks</span><span class="p">)</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">_labelNeedsUpdate</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">label</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">_labels</span><span class="p">}</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">_timeline</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">_timelineNeedsUpdate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">annotation</span></div>

    <span class="k">def</span> <span class="nf">_repr_png_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;IPython notebook support</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :mod:`pyannote.core.notebook`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.notebook</span> <span class="kn">import</span> <span class="n">repr_annotation</span>
        <span class="k">return</span> <span class="n">repr_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, CNRS

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>