

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reference &mdash; pyannote.core 3.7 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="Serialization" href="serialization.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pyannote.core
          

          
          </a>

          
            
            
              <div class="version">
                3.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="structure.html">Available data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="serialization.html">Serialization</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#data-structures">Data structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#segment">Segment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timeline">Timeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="#annotation">Annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slidingwindow">SlidingWindow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slidingwindowfeature">SlidingWindowFeature</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyannote.core.json">Serialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyannote.core.notebook">Visualization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Visualization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyannote.core</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/reference.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="data-structures">
<h2>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="segment">
<h3>Segment<a class="headerlink" href="#segment" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyannote.core.Segment">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.core.</code><code class="sig-name descname">Segment</code><span class="sig-paren">(</span><em class="sig-param">start: float = 0.0</em>, <em class="sig-param">end: float = 0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Time interval</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – interval start time, in seconds.</p></li>
<li><p><strong>end</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – interval end time, in seconds.</p></li>
</ul>
</dd>
</dl>
<p>Segments can be compared and sorted using the standard operators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A segment is smaller than another segment if one of these two conditions is verified:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>segment.start &lt; other_segment.start</cite></p></li>
<li><p><cite>segment.start == other_segment.start</cite> and <cite>segment.end &lt; other_segment.end</cite></p></li>
</ul>
</div></blockquote>
</div>
<dl class="method">
<dt id="pyannote.core.Segment.__and__">
<code class="sig-name descname">__and__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__and__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__and__" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersection</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other_segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">&amp;</span> <span class="n">other_segment</span>
<span class="go">&lt;Segment(5, 10)&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the intersection is empty, an empty segment is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other_segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intersection</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">&amp;</span> <span class="n">other_segment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">intersection</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># intersection is empty.</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__bool__">
<code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__bool__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__bool__" title="Permalink to this definition">¶</a></dt>
<dd><p>Emptiness</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">segment</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># segment is not empty.</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># segment is empty.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A segment is considered empty if its end time is smaller than its
start time, or its duration is smaller than 1μs.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.segment.Segment</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__contains__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inclusion</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">:</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">:</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Iterator[float]<a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack segment boundaries
&gt;&gt;&gt; segment = Segment(start, end)
&gt;&gt;&gt; start, end = segment</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__or__">
<code class="sig-name descname">__or__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__or__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__or__" title="Permalink to this definition">¶</a></dt>
<dd><p>Union</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other_segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">|</span> <span class="n">other_segment</span>
<span class="go">&lt;Segment(0, 15)&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a gap exists between the segment, their union covers the gap as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other_segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">|</span> <span class="n">other_segment</span>
<span class="go">&lt;Segment(0, 20)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Computer-readable representation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="mi">1337</span> <span class="o">+</span> <span class="mf">0.42</span><span class="p">)</span>
<span class="go">&lt;Segment(1337, 1337.42)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-readable representation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="mi">1337</span> <span class="o">+</span> <span class="mf">0.42</span><span class="p">))</span>
<span class="go">[ 00:22:17.000 --&gt;  00:22:17.420]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Empty segments are printed as “[]”</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyannote.core.Segment.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pyannote.core.Segment.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.__xor__">
<code class="sig-name descname">__xor__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.__xor__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.__xor__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gap</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other_segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">^</span> <span class="n">other_segment</span>
<span class="go">&lt;Segment(10, 15)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The gap between a segment and an empty segment is not defined.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">empty_segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">^</span> <span class="n">empty_segment</span>
<span class="go">ValueError: The gap between a segment and an empty segment is not defined.</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the segment</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>copy</strong> – Copy of the segment.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.duration">
<em class="property">property </em><code class="sig-name descname">duration</code><a class="headerlink" href="#pyannote.core.Segment.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Segment duration (read-only)</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.for_json">
<code class="sig-name descname">for_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.for_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.for_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialization</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-pyannote.core.json" title="pyannote.core.json"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyannote.core.json</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.from_json">
<em class="property">classmethod </em><code class="sig-name descname">from_json</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialization</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-pyannote.core.json" title="pyannote.core.json"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyannote.core.json</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.intersects">
<code class="sig-name descname">intersects</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.intersects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether two segments intersect each other</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Other segment</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intersect</strong> – True if segments intersect, False otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.middle">
<em class="property">property </em><code class="sig-name descname">middle</code><a class="headerlink" href="#pyannote.core.Segment.middle" title="Permalink to this definition">¶</a></dt>
<dd><p>Segment mid-time (read-only)</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Segment.overlaps">
<code class="sig-name descname">overlaps</code><span class="sig-paren">(</span><em class="sig-param">t: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/pyannote/core/segment.html#Segment.overlaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Segment.overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if segment overlaps a given time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Time, in seconds.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>overlap</strong> – True if segment overlaps time t, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timeline">
<h3>Timeline<a class="headerlink" href="#timeline" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyannote.core.Timeline">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.core.</code><code class="sig-name descname">Timeline</code><span class="sig-paren">(</span><em class="sig-param">segments: Optional[Iterable[pyannote.core.segment.Segment]] = None</em>, <em class="sig-param">uri: str = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordered set of segments.</p>
<p>A timeline can be seen as an ordered set of non-empty segments (Segment).
Segments can overlap – though adding an already exisiting segment to a
timeline does nothing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>segments</strong> (<em>Segment iterator</em><em>, </em><em>optional</em>) – initial set of (non-empty) segments</p></li>
<li><p><strong>uri</strong> (<em>string</em><em>, </em><em>optional</em>) – name of segmented resource</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>timeline</strong> – New timeline</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.core.Timeline.__bool__">
<code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__bool__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__bool__" title="Permalink to this definition">¶</a></dt>
<dd><p>Emptiness</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">timeline</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># timeline is empty</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># timeline is not empty</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">included: Union[pyannote.core.segment.Segment, Timeline]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__contains__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inclusion</p>
<p>Check whether every segment of <cite>included</cite> does exist in timeline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>included</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – Segment or timeline being checked for inclusion</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>contains</strong> – True if every segment in <cite>included</cite> exists in timeline,
False otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline1</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline2</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline1</span> <span class="ow">in</span> <span class="n">timeline2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline2</span> <span class="ow">in</span> <span class="n">timeline1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">)</span> <span class="ow">in</span> <span class="n">timeline1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.timeline.Timeline</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality</p>
<p>Two timelines are equal if and only if their segments are equal.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline1</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline2</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline3</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline1</span> <span class="o">==</span> <span class="n">timeline2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline1</span> <span class="o">==</span> <span class="n">timeline3</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">k: int</em><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get segment by index (in chronological order)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">first_segment</span> <span class="o">=</span> <span class="n">timeline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">penultimate_segment</span> <span class="o">=</span> <span class="n">timeline</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">segments: Optional[Iterable[pyannote.core.segment.Segment]] = None</em>, <em class="sig-param">uri: str = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Iterable[pyannote.core.segment.Segment]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over segments (in chronological order)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">timeline</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># do something with the segment</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.core.Segment</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of segments</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">timeline</span><span class="p">)</span>  <span class="c1"># timeline contains three segments</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__ne__">
<code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.timeline.Timeline</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inequality</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Computer-readable representation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">)])</span>
<span class="go">&lt;Timeline(uri=None, segments=[&lt;Segment(0, 10)&gt;, &lt;Segment(1, 13.37)&gt;])&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-readable representation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">timeline</span><span class="p">)</span>
<span class="go">[[ 00:00:00.000 --&gt;  00:00:10.000]</span>
<span class="go"> [ 00:00:01.000 --&gt;  00:00:13.370]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyannote.core.Timeline.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pyannote.core.Timeline.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a segment (in place)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Segment that is being added</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Updated timeline.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the timeline already contains this segment, it will not be added
again, as a timeline is meant to be a <strong>set</strong> of segments (not a list).</p>
<p>If the segment is empty, it will not be added either, as a timeline
only contains non-empty segments.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.co_iter">
<code class="sig-name descname">co_iter</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.timeline.Timeline</em><span class="sig-paren">)</span> &#x2192; Iterator[Tuple[pyannote.core.segment.Segment, pyannote.core.segment.Segment]]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.co_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.co_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over pairs of intersecting segments</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline1</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline2</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">segment1</span><span class="p">,</span> <span class="n">segment2</span> <span class="ow">in</span> <span class="n">timeline1</span><span class="o">.</span><span class="n">co_iter</span><span class="p">(</span><span class="n">timeline2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">segment1</span><span class="p">,</span> <span class="n">segment2</span><span class="p">)</span>
<span class="go">(&lt;Segment(0, 2)&gt;, &lt;Segment(1, 3)&gt;)</span>
<span class="go">(&lt;Segment(1, 2)&gt;, &lt;Segment(1, 3)&gt;)</span>
<span class="go">(&lt;Segment(3, 4)&gt;, &lt;Segment(3, 5)&gt;)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – Second timeline</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>iterable</strong> – Yields pairs of intersecting segments in chronological order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a>, <a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a>) iterable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">segment_func: Optional[Callable[[pyannote.core.segment.Segment], pyannote.core.segment.Segment]] = None</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the timeline</p>
<p>If <cite>segment_func</cite> is provided, it is applied to each segment first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>segment_func</strong> (<em>callable</em><em>, </em><em>optional</em>) – Callable that takes a segment as input, and returns a segment.
Defaults to identity function (segment_func(segment) = segment)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>timeline</strong> – Copy of the timeline</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.covers">
<code class="sig-name descname">covers</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.timeline.Timeline</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.covers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether other timeline is fully covered by the timeline</p>
<dl class="simple">
<dt>other<span class="classifier">Timeline</span></dt><dd><p>Second timeline</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>covers</strong> – True if timeline covers “other” timeline entirely. False if at least
one segment of “other” is not fully covered by timeline</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.crop">
<code class="sig-name descname">crop</code><span class="sig-paren">(</span><em class="sig-param">support: Union[Segment, Timeline], mode: typing_extensions.Literal['intersection', 'loose', 'strict'][intersection, loose, strict] = 'intersection', returns_mapping: bool = False</em><span class="sig-paren">)</span> &#x2192; Union[pyannote.core.timeline.Timeline, Tuple[pyannote.core.timeline.Timeline, Dict[pyannote.core.segment.Segment, pyannote.core.segment.Segment]]]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.crop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop timeline to new support</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>support</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – If <cite>support</cite> is a <cite>Timeline</cite>, its support is used.</p></li>
<li><p><strong>mode</strong> (<em>{'strict'</em><em>, </em><em>'loose'</em><em>, </em><em>'intersection'}</em><em>, </em><em>optional</em>) – Controls how segments that are not fully included in <cite>support</cite> are
handled. ‘strict’ mode only keeps fully included segments. ‘loose’
mode keeps any intersecting segment. ‘intersection’ mode keeps any
intersecting segment but replace them by their actual intersection.</p></li>
<li><p><strong>returns_mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – In ‘intersection’ mode, return a dictionary whose keys are segments
of the cropped timeline, and values are list of the original
segments that were cropped. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cropped</strong> (<em>Timeline</em>) – Cropped timeline</p></li>
<li><p><strong>mapping</strong> (<em>dict</em>) – When ‘returns_mapping’ is True, dictionary whose keys are segments
of ‘cropped’, and values are lists of corresponding original
segments.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">&lt;Timeline(uri=None, segments=[&lt;Segment(1, 2)&gt;])&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;loose&#39;</span><span class="p">)</span>
<span class="go">&lt;Timeline(uri=None, segments=[&lt;Segment(0, 2)&gt;, &lt;Segment(1, 2)&gt;])&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;strict&#39;</span><span class="p">)</span>
<span class="go">&lt;Timeline(uri=None, segments=[&lt;Segment(1, 2)&gt;])&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cropped</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">timeline</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">returns_mapping</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
<span class="go">{&lt;Segment(1, 2)&gt;: [&lt;Segment(0, 2)&gt;, &lt;Segment(1, 2)&gt;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.crop_iter">
<code class="sig-name descname">crop_iter</code><span class="sig-paren">(</span><em class="sig-param">support: Union[Segment, Timeline], mode: typing_extensions.Literal['intersection', 'loose', 'strict'][intersection, loose, strict] = 'intersection', returns_mapping: bool = False</em><span class="sig-paren">)</span> &#x2192; Iterator[Union[Tuple[pyannote.core.segment.Segment, pyannote.core.segment.Segment], pyannote.core.segment.Segment]]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.crop_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.crop_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>crop</cite> but returns a segment iterator instead</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.crop" title="pyannote.core.Timeline.crop"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyannote.core.Timeline.crop()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.discard">
<code class="sig-name descname">discard</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.discard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <cite>remove</cite></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.remove" title="pyannote.core.Timeline.remove"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyannote.core.Timeline.remove()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.duration">
<code class="sig-name descname">duration</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.duration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Timeline duration</p>
<p>The timeline duration is the sum of the durations of the segments
in the timeline support.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>duration</strong> – Duration of timeline support, in seconds.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty copy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – Empty timeline using the same ‘uri’ attribute.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.extent">
<code class="sig-name descname">extent</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.extent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.extent" title="Permalink to this definition">¶</a></dt>
<dd><p>Extent</p>
<p>The extent of a timeline is the segment of minimum duration that
contains every segments of the timeline. It is unique, by definition.
The extent of an empty timeline is an empty segment.</p>
<p>A picture is worth a thousand words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timeline</span>
<span class="o">|------|</span>    <span class="o">|------|</span>     <span class="o">|----|</span>
  <span class="o">|--|</span>    <span class="o">|-----|</span>     <span class="o">|----------|</span>

<span class="n">timeline</span><span class="o">.</span><span class="n">extent</span><span class="p">()</span>
<span class="o">|--------------------------------|</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>extent</strong> – Timeline extent</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">(</span><span class="n">segments</span><span class="o">=</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeline</span><span class="o">.</span><span class="n">extent</span><span class="p">()</span>
<span class="go">&lt;Segment(0, 10)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.for_json">
<code class="sig-name descname">for_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.for_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.for_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialization</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-pyannote.core.json" title="pyannote.core.json"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyannote.core.json</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.from_json">
<em class="property">classmethod </em><code class="sig-name descname">from_json</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialization</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-pyannote.core.json" title="pyannote.core.json"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyannote.core.json</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.gaps">
<code class="sig-name descname">gaps</code><span class="sig-paren">(</span><em class="sig-param">support: Union[Segment</em>, <em class="sig-param">Timeline</em>, <em class="sig-param">None] = None</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.gaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.gaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaps</p>
<p>A picture is worth a thousand words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timeline</span>
<span class="o">|------|</span>    <span class="o">|------|</span>     <span class="o">|----|</span>
  <span class="o">|--|</span>    <span class="o">|-----|</span>     <span class="o">|----------|</span>

<span class="n">timeline</span><span class="o">.</span><span class="n">gaps</span><span class="p">()</span>
       <span class="o">|--|</span>        <span class="o">|--|</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>support</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.8)"><em>None</em></a><em>, </em><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – Support in which gaps are looked for. Defaults to timeline extent</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>gaps</strong> – Timeline made of all gaps from original timeline, and delimited
by provided support</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.extent" title="pyannote.core.Timeline.extent"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyannote.core.Timeline.extent()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.gaps_iter">
<code class="sig-name descname">gaps_iter</code><span class="sig-paren">(</span><em class="sig-param">support: Union[Segment</em>, <em class="sig-param">Timeline</em>, <em class="sig-param">None] = None</em><span class="sig-paren">)</span> &#x2192; Iterator[pyannote.core.segment.Segment]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.gaps_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.gaps_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>gaps</cite> but returns a segment generator instead</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.gaps" title="pyannote.core.Timeline.gaps"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyannote.core.Timeline.gaps()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of (existing) segment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Segment that is being looked for.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>position</strong> – Index of <cite>segment</cite> in timeline</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError if segment is not present.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.overlapping">
<code class="sig-name descname">overlapping</code><span class="sig-paren">(</span><em class="sig-param">t: float</em><span class="sig-paren">)</span> &#x2192; List[pyannote.core.segment.Segment]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.overlapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.overlapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of segments overlapping <cite>t</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Timestamp, in seconds.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>segments</strong> – List of all segments of timeline containing time t</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.overlapping_iter">
<code class="sig-name descname">overlapping_iter</code><span class="sig-paren">(</span><em class="sig-param">t: float</em><span class="sig-paren">)</span> &#x2192; Iterator[pyannote.core.segment.Segment]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.overlapping_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.overlapping_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>overlapping</cite> but returns a segment iterator instead</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.overlapping" title="pyannote.core.Timeline.overlapping"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyannote.core.Timeline.overlapping()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a segment (in place)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Segment that is being removed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Updated timeline.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the timeline does not contain this segment, this does nothing</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.segmentation">
<code class="sig-name descname">segmentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.segmentation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.segmentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Segmentation</p>
<p>Create the unique timeline with same support and same set of segment
boundaries as original timeline, but with no overlapping segments.</p>
<p>A picture is worth a thousand words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timeline</span>
<span class="o">|------|</span>    <span class="o">|------|</span>     <span class="o">|----|</span>
  <span class="o">|--|</span>    <span class="o">|-----|</span>     <span class="o">|----------|</span>

<span class="n">timeline</span><span class="o">.</span><span class="n">segmentation</span><span class="p">()</span>
<span class="o">|-|--|-|</span>  <span class="o">|-|---|--|</span>  <span class="o">|--|----|--|</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>timeline</strong> – (unique) timeline with same support and same set of segment
boundaries as original timeline, but with no overlapping segments.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.support">
<code class="sig-name descname">support</code><span class="sig-paren">(</span><em class="sig-param">collar: float = 0.0</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.support"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.support" title="Permalink to this definition">¶</a></dt>
<dd><p>Timeline support</p>
<p>The support of a timeline is the timeline with the minimum number of
segments with exactly the same time span as the original timeline. It
is (by definition) unique and does not contain any overlapping
segments.</p>
<p>A picture is worth a thousand words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">collar</span>
<span class="o">|---|</span>

<span class="n">timeline</span>
<span class="o">|------|</span>    <span class="o">|------|</span>      <span class="o">|----|</span>
  <span class="o">|--|</span>    <span class="o">|-----|</span>      <span class="o">|----------|</span>

<span class="n">timeline</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="o">|------|</span>  <span class="o">|--------|</span>   <span class="o">|----------|</span>

<span class="n">timeline</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">collar</span><span class="p">)</span>
<span class="o">|------------------|</span>   <span class="o">|----------|</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Merge separated by less than <cite>collar</cite> seconds. This is why there
are only two segments in the final timeline in the above figure.
Defaults to 0.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>support</strong> – Timeline support</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.support_iter">
<code class="sig-name descname">support_iter</code><span class="sig-paren">(</span><em class="sig-param">collar: float = 0.0</em><span class="sig-paren">)</span> &#x2192; Iterator[pyannote.core.segment.Segment]<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.support_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.support_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>support</cite> but returns a segment generator instead</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.support" title="pyannote.core.Timeline.support"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyannote.core.Timeline.support()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.to_annotation">
<code class="sig-name descname">to_annotation</code><span class="sig-paren">(</span><em class="sig-param">generator: Union[str, Iterable[Hashable], None] = 'string', modality: Optional[str] = None</em><span class="sig-paren">)</span> &#x2192; Annotation<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.to_annotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.to_annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn timeline into an annotation</p>
<p>Each segment is labeled by a unique label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generator</strong> (<em>'string'</em><em>, </em><em>'int'</em><em>, or </em><em>iterable</em><em>, </em><em>optional</em>) – If ‘string’ (default) generate string labels. If ‘int’, generate
integer labels. If iterable, use it to generate labels.</p></li>
<li><p><strong>modality</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>annotation</strong> – Annotation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.union">
<code class="sig-name descname">union</code><span class="sig-paren">(</span><em class="sig-param">timeline: pyannote.core.timeline.Timeline</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new timeline made of union of segments</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeline</strong> (<a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – Timeline whose segments are being added</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – New timeline containing the union of both timelines.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This does the same as timeline.update(…) except it returns a new
timeline, and the original one is not modified.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">timeline: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Add every segments of an existing timeline (in place)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeline</strong> (<a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – Timeline whose segments are being added</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Updated timeline</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only segments that do not already exist will be added, as a timeline is
meant to be a <strong>set</strong> of segments (not a list).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Timeline.write_uem">
<code class="sig-name descname">write_uem</code><span class="sig-paren">(</span><em class="sig-param">file: TextIO</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/timeline.html#Timeline.write_uem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Timeline.write_uem" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump timeline to file using UEM format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<em>file object</em>) – </p></li>
<li><p><strong>Usage</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>with open</strong><strong>(</strong><strong>'file.uem'</strong><strong>, </strong><strong>'w'</strong><strong>) </strong><strong>as file</strong> (<em>&gt;&gt;&gt;</em>) – </p></li>
<li><p><strong>timeline.write_uem</strong><strong>(</strong><strong>file</strong><strong>)</strong> (<em>..</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="annotation">
<h3>Annotation<a class="headerlink" href="#annotation" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyannote.core.Annotation">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.core.</code><code class="sig-name descname">Annotation</code><span class="sig-paren">(</span><em class="sig-param">uri: Optional[str] = None</em>, <em class="sig-param">modality: Optional[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uri</strong> (<em>string</em><em>, </em><em>optional</em>) – name of annotated resource (e.g. audio or video file)</p></li>
<li><p><strong>modality</strong> (<em>string</em><em>, </em><em>optional</em>) – name of annotated modality</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>annotation</strong> – New annotation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.core.Annotation.__bool__">
<code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__bool__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__bool__" title="Permalink to this definition">¶</a></dt>
<dd><p>Emptiness</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">annotation</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># annotation is empty</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># annotation is not empty</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">included: Union[pyannote.core.segment.Segment, pyannote.core.timeline.Timeline]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__contains__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inclusion</p>
<p>Check whether every segment of <cite>included</cite> does exist in annotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>included</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – Segment or timeline being checked for inclusion</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>contains</strong> – True if every segment in <cite>included</cite> exists in timeline,
False otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__delitem__">
<code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param">key: Union[Segment, Tuple[Segment, Union[str, int]]]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__delitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete one track</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">annotation</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">]</span>
</pre></div>
</div>
<p>Delete all tracks of a segment</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">annotation</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.annotation.Annotation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span> <span class="o">==</span> <span class="n">other</span>
</pre></div>
</div>
<p>Two annotations are equal if and only if their tracks and associated
labels are equal.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">key: Union[Segment, Tuple[Segment, Union[str, int]]]</em><span class="sig-paren">)</span> &#x2192; Hashable<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get track label</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">label</span> <span class="o">=</span> <span class="n">annotation</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">annotation[segment]</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">annotation[segment,</span> <span class="pre">'_']</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">uri: Optional[str] = None</em>, <em class="sig-param">modality: Optional[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of segments</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>  <span class="c1"># annotation contains three segments</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__mul__">
<code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.annotation.Annotation</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Cooccurrence (or confusion) matrix</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">annotation</span> <span class="o">*</span> <span class="n">other</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation"><em>Annotation</em></a>) – Second annotation</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cooccurrence</strong> – Cooccurrence matrix where <cite>n_self</cite> (resp. <cite>n_other</cite>) is the number
of labels in <cite>self</cite> (resp. <cite>other</cite>).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n_self, n_other) np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__ne__">
<code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.annotation.Annotation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inequality</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">key: Union[Segment, Tuple[Segment, Union[str, int]]], label: Hashable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new or update existing track</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
</pre></div>
</div>
<p>If (segment, track) does not exist, it is added.
If (segment, track) already exists, it is updated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">annotation[segment]</span> <span class="pre">=</span> <span class="pre">label</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">annotation[segment,</span> <span class="pre">'_']</span> <span class="pre">=</span> <span class="pre">label</span></code></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <cite>segment</cite> is empty, it does nothing.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-friendly representation</p>
</dd></dl>

<dl class="attribute">
<dt id="pyannote.core.Annotation.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pyannote.core.Annotation.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.argmax">
<code class="sig-name descname">argmax</code><span class="sig-paren">(</span><em class="sig-param">support: Union[Segment</em>, <em class="sig-param">Timeline</em>, <em class="sig-param">None] = None</em><span class="sig-paren">)</span> &#x2192; Optional[Hashable]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.argmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Get label with longest duration</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>support</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a><em>, </em><em>optional</em>) – Find label with longest duration within provided support.
Defaults to whole extent.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>label</strong> – Label with longest intersection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any existing label or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.8)">None</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">modality</span><span class="o">=</span><span class="s1">&#39;speaker&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="s1">&#39;speaker1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Alice&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="s1">&#39;speaker1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Bob&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is such a talker!&quot;</span> <span class="o">%</span> <span class="n">annotation</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="go">Bob is such a talker!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">annotation</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">support</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="s2">&quot;No label intersecting </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">segment</span>
<span class="go">No label intersection [22 --&gt; 23]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.chart">
<code class="sig-name descname">chart</code><span class="sig-paren">(</span><em class="sig-param">percent: bool = False</em><span class="sig-paren">)</span> &#x2192; List[Tuple[Hashable, float]]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.chart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.chart" title="Permalink to this definition">¶</a></dt>
<dd><p>Get labels chart (from longest to shortest duration)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>percent</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Return list of (label, percentage) tuples.
Defaults to returning list of (label, duration) tuples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>chart</strong> – List of (label, duration), sorted by duration in decreasing order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.co_iter">
<code class="sig-name descname">co_iter</code><span class="sig-paren">(</span><em class="sig-param">other: pyannote.core.annotation.Annotation</em><span class="sig-paren">)</span> &#x2192; Iterator[Tuple[Tuple[pyannote.core.segment.Segment, Union[str, int]], Tuple[pyannote.core.segment.Segment, Union[str, int]]]]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.co_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.co_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over pairs of intersecting tracks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation"><em>Annotation</em></a>) – Second annotation</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>iterable</strong> – Yields pairs of intersecting tracks, in chronological (then
alphabetical) order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a>), (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a>) iterable</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Timeline.co_iter" title="pyannote.core.Timeline.co_iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">co_iter()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the annotation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>annotation</strong> – Copy of the annotation</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.crop">
<code class="sig-name descname">crop</code><span class="sig-paren">(</span><em class="sig-param">support: Union[Segment, Timeline], mode: typing_extensions.Literal['intersection', 'loose', 'strict'][intersection, loose, strict] = 'intersection'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.crop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop annotation to new support</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>support</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – If <cite>support</cite> is a <cite>Timeline</cite>, its support is used.</p></li>
<li><p><strong>mode</strong> (<em>{'strict'</em><em>, </em><em>'loose'</em><em>, </em><em>'intersection'}</em><em>, </em><em>optional</em>) – Controls how segments that are not fully included in <cite>support</cite> are
handled. ‘strict’ mode only keeps fully included segments. ‘loose’
mode keeps any intersecting segment. ‘intersection’ mode keeps any
intersecting segment but replace them by their actual intersection.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cropped</strong> – Cropped annotation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In ‘intersection’ mode, the best is done to keep the track names
unchanged. However, in some cases where two original segments are
cropped into the same resulting segments, conflicting track names are
modified to make sure no track is lost.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty copy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – Empty annotation using the same ‘uri’ and ‘modality’ attributes.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.for_json">
<code class="sig-name descname">for_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Dict<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.for_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.for_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialization</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-pyannote.core.json" title="pyannote.core.json"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyannote.core.json</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.from_json">
<em class="property">classmethod </em><code class="sig-name descname">from_json</code><span class="sig-paren">(</span><em class="sig-param">data: Dict</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialization</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-pyannote.core.json" title="pyannote.core.json"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyannote.core.json</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.from_records">
<em class="property">classmethod </em><code class="sig-name descname">from_records</code><span class="sig-paren">(</span><em class="sig-param">records: Iterator[Tuple[pyannote.core.segment.Segment, Union[str, int], Hashable]], uri: Optional[str] = None, modality: Optional[str] = None</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.from_records"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.from_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>records</strong> (<em>iterator of tuples</em>) – (segment, track, label) tuples</p></li>
<li><p><strong>uri</strong> (<em>string</em><em>, </em><em>optional</em>) – name of annotated resource (e.g. audio or video file)</p></li>
<li><p><strong>modality</strong> (<em>string</em><em>, </em><em>optional</em>) – name of annotated modality</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>annotation</strong> – New annotation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.get_labels">
<code class="sig-name descname">get_labels</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em>, <em class="sig-param">unique: bool = True</em><span class="sig-paren">)</span> &#x2192; Set[Hashable]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.get_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.get_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Query labels by segment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Query</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – When False, return the list of (possibly repeated) labels.
Defaults to returning the set of labels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>labels</strong> – Set of labels for <cite>segment</cite> if it exists, empty set otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.8)">set</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;speaker1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Bernard&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;speaker2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;John&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">segment</span><span class="p">))</span>
<span class="go">set([&#39;Bernard&#39;, &#39;John&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">annotation</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">set([])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.get_timeline">
<code class="sig-name descname">get_timeline</code><span class="sig-paren">(</span><em class="sig-param">copy: bool = True</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.get_timeline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.get_timeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Get timeline made of all annotated segments</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Defaults (True) to returning a copy of the internal timeline.
Set to False to return the actual internal timeline (faster).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>timeline</strong> – Timeline made of all annotated segments.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In case copy is set to False, be careful <strong>not</strong> to modify the returned
timeline, as it may lead to weird subsequent behavior of the annotation
instance.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.get_tracks">
<code class="sig-name descname">get_tracks</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; Set[Union[str, int]]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.get_tracks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.get_tracks" title="Permalink to this definition">¶</a></dt>
<dd><p>Query tracks by segment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Query</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tracks</strong> – Set of tracks</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.8)">set</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will return an empty set if segment does not exist.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.has_track">
<code class="sig-name descname">has_track</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment, track: Union[str, int]</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.has_track"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.has_track" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a given track exists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Query segment</p></li>
<li><p><strong>track</strong> – Query track</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>exists</strong> – True if track exists for segment</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.itersegments">
<code class="sig-name descname">itersegments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.itersegments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.itersegments" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over segments (in chronological order)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">itersegments</span><span class="p">():</span>
<span class="gp">... </span>    <span class="c1"># do something with the segment</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.core.Segment</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.itertracks">
<code class="sig-name descname">itertracks</code><span class="sig-paren">(</span><em class="sig-param">yield_label: bool = False</em><span class="sig-paren">)</span> &#x2192; Iterator[Union[Tuple[pyannote.core.segment.Segment, Union[str, int]], Tuple[pyannote.core.segment.Segment, Union[str, int], Hashable]]]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.itertracks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.itertracks" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over tracks (in chronological order)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>yield_label</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – When True, yield (segment, track, label) tuples, such that
annotation[segment, track] == label. Defaults to yielding
(segment, track) tuple.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">itertracks</span><span class="p">():</span>
<span class="gp">... </span>    <span class="c1"># do something with the track</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">segment</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">itertracks</span><span class="p">(</span><span class="n">yield_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># do something with the track and its label</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.label_duration">
<code class="sig-name descname">label_duration</code><span class="sig-paren">(</span><em class="sig-param">label: Hashable</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.label_duration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.label_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Label duration</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">Annotation.label_timeline(label).duration()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><em>object</em></a>) – Query</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>duration</strong> – Duration, in seconds.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Annotation.label_timeline" title="pyannote.core.Annotation.label_timeline"><code class="xref py py-func docutils literal notranslate"><span class="pre">label_timeline()</span></code></a>
<a class="reference internal" href="#pyannote.core.Timeline.duration" title="pyannote.core.Timeline.duration"><code class="xref py py-func docutils literal notranslate"><span class="pre">duration()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.label_support">
<code class="sig-name descname">label_support</code><span class="sig-paren">(</span><em class="sig-param">label: Hashable</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.label_support"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.label_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Label support</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">Annotation.label_timeline(label).support()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><em>object</em></a>) – Query</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>support</strong> – Label support</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.Annotation.label_timeline" title="pyannote.core.Annotation.label_timeline"><code class="xref py py-func docutils literal notranslate"><span class="pre">label_timeline()</span></code></a>
<a class="reference internal" href="#pyannote.core.Timeline.support" title="pyannote.core.Timeline.support"><code class="xref py py-func docutils literal notranslate"><span class="pre">support()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.label_timeline">
<code class="sig-name descname">label_timeline</code><span class="sig-paren">(</span><em class="sig-param">label: Hashable</em>, <em class="sig-param">copy: bool = True</em><span class="sig-paren">)</span> &#x2192; pyannote.core.timeline.Timeline<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.label_timeline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.label_timeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Query segments by label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><em>object</em></a>) – Query</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Defaults (True) to returning a copy of the internal timeline.
Set to False to return the actual internal timeline (faster).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>timeline</strong> – Timeline made of all segments for which at least one track is
annotated as label</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline">Timeline</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If label does not exist, this will return an empty timeline.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In case copy is set to False, be careful <strong>not</strong> to modify the returned
timeline, as it may lead to weird subsequent behavior of the annotation
instance.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.labels">
<code class="sig-name descname">labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[Hashable]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get sorted list of labels</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>labels</strong> – Sorted list of labels</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.new_track">
<code class="sig-name descname">new_track</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em>, <em class="sig-param">candidate: Union[str</em>, <em class="sig-param">int</em>, <em class="sig-param">None] = None</em>, <em class="sig-param">prefix: Optional[str] = None</em><span class="sig-paren">)</span> &#x2192; Union[str, int]<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.new_track"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.new_track" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a new track name for given segment</p>
<p>Ensures that the returned track name does not already
exist for the given segment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – Segment for which a new track name is generated.</p></li>
<li><p><strong>candidate</strong> (<em>any valid track name</em><em>, </em><em>optional</em>) – When provided, try this candidate name first.</p></li>
<li><p><strong>prefix</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Track name prefix. Defaults to the empty string ‘’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>name</strong> – New track name</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)">str</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.relabel_tracks">
<code class="sig-name descname">relabel_tracks</code><span class="sig-paren">(</span><em class="sig-param">generator: Union[typing_extensions.Literal['int', 'string'][int, string], Iterator[Hashable]] = 'string'</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.relabel_tracks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.relabel_tracks" title="Permalink to this definition">¶</a></dt>
<dd><p>Relabel tracks</p>
<p>Create a new annotation where each track has a unique label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>generator</strong> (<em>'string'</em><em>, </em><em>'int'</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – If ‘string’ (default) relabel tracks to ‘A’, ‘B’, ‘C’, … If ‘int’
relabel to 0, 1, 2, … If iterable, use it to generate labels.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>renamed</strong> – New annotation with relabeled tracks.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.rename_labels">
<code class="sig-name descname">rename_labels</code><span class="sig-paren">(</span><em class="sig-param">mapping: Optional[Dict] = None, generator: Union[typing_extensions.Literal['int', 'string'][int, string], Iterator[Hashable]] = 'string', copy: bool = True</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.rename_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.rename_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><em>optional</em>) – {old_name: new_name} mapping dictionary.</p></li>
<li><p><strong>generator</strong> (<em>'string'</em><em>, </em><em>'int'</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – If ‘string’ (default) rename label to ‘A’, ‘B’, ‘C’, … If ‘int’,
rename to 0, 1, 2, etc. If iterable, use it to generate labels.</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to return a copy of the annotation. Set to False to
update the annotation in-place. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>renamed</strong> – Annotation where labels have been renamed</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unmapped labels are kept unchanged.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>generator</cite> has no effect when <cite>mapping</cite> is provided.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.rename_tracks">
<code class="sig-name descname">rename_tracks</code><span class="sig-paren">(</span><em class="sig-param">generator: Union[typing_extensions.Literal['int', 'string'][int, string], Iterator[Hashable]] = 'string'</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.rename_tracks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.rename_tracks" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename all tracks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>generator</strong> (<em>'string'</em><em>, </em><em>'int'</em><em>, or </em><em>iterable</em><em>, </em><em>optional</em>) – If ‘string’ (default) rename tracks to ‘A’, ‘B’, ‘C’, etc.
If ‘int’, rename tracks to 0, 1, 2, etc.
If iterable, use it to generate track names.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>renamed</strong> – Copy of the original annotation where tracks are renamed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotation</span><span class="p">[</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
<span class="go">[ 00:00:00.000 --&gt;  00:00:01.000] a a</span>
<span class="go">[ 00:00:00.000 --&gt;  00:00:01.000] b b</span>
<span class="go">[ 00:00:01.000 --&gt;  00:00:02.000] a a</span>
<span class="go">[ 00:00:01.000 --&gt;  00:00:03.000] c c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">rename_tracks</span><span class="p">(</span><span class="n">generator</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
<span class="go">[ 00:00:00.000 --&gt;  00:00:01.000] 0 a</span>
<span class="go">[ 00:00:00.000 --&gt;  00:00:01.000] 1 b</span>
<span class="go">[ 00:00:01.000 --&gt;  00:00:02.000] 2 a</span>
<span class="go">[ 00:00:01.000 --&gt;  00:00:03.000] 3 c</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.subset">
<code class="sig-name descname">subset</code><span class="sig-paren">(</span><em class="sig-param">labels: Iterable[Hashable], invert: bool = False</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter annotation by labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<em>iterable</em>) – List of filtered labels</p></li>
<li><p><strong>invert</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – If invert is True, extract all but requested labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>filtered</strong> – Filtered annotation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.support">
<code class="sig-name descname">support</code><span class="sig-paren">(</span><em class="sig-param">collar: float = 0.0</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.support"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.support" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotation support</p>
<p>The support of an annotation is an annotation where contiguous tracks
with same label are merged into one unique covering track.</p>
<p>A picture is worth a thousand words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">collar</span>
<span class="o">|---|</span>

<span class="n">annotation</span>
<span class="o">|--</span><span class="n">A</span><span class="o">--|</span> <span class="o">|--</span><span class="n">A</span><span class="o">--|</span>     <span class="o">|-</span><span class="n">B</span><span class="o">-|</span>
  <span class="o">|-</span><span class="n">B</span><span class="o">-|</span>    <span class="o">|--</span><span class="n">C</span><span class="o">--|</span>     <span class="o">|----</span><span class="n">B</span><span class="o">-----|</span>

<span class="n">annotation</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">collar</span><span class="p">)</span>
<span class="o">|------</span><span class="n">A</span><span class="o">------|</span>     <span class="o">|------</span><span class="n">B</span><span class="o">------|</span>
  <span class="o">|-</span><span class="n">B</span><span class="o">-|</span>    <span class="o">|--</span><span class="n">C</span><span class="o">--|</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Merge tracks with same label and separated by less than <cite>collar</cite>
seconds. This is why ‘A’ tracks are merged in above figure.
Defaults to 0.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>support</strong> – Annotation support</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Track names are lost in the process.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">annotation: pyannote.core.annotation.Annotation</em>, <em class="sig-param">copy: bool = False</em><span class="sig-paren">)</span> &#x2192; pyannote.core.annotation.Annotation<a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Add every track of an existing annotation (in place)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>annotation</strong> (<a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation"><em>Annotation</em></a>) – Annotation whose tracks are being added</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Return a copy of the annotation. Defaults to updating the
annotation in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Updated annotation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Annotation" title="pyannote.core.Annotation">Annotation</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Existing tracks are updated with the new label.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.Annotation.write_rttm">
<code class="sig-name descname">write_rttm</code><span class="sig-paren">(</span><em class="sig-param">file: TextIO</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/annotation.html#Annotation.write_rttm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.Annotation.write_rttm" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump annotation to file using RTTM format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<em>file object</em>) – </p></li>
<li><p><strong>Usage</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>with open</strong><strong>(</strong><strong>'file.rttm'</strong><strong>, </strong><strong>'w'</strong><strong>) </strong><strong>as file</strong> (<em>&gt;&gt;&gt;</em>) – </p></li>
<li><p><strong>annotation.write_rttm</strong><strong>(</strong><strong>file</strong><strong>)</strong> (<em>..</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="slidingwindow">
<h3>SlidingWindow<a class="headerlink" href="#slidingwindow" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyannote.core.SlidingWindow">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.core.</code><code class="sig-name descname">SlidingWindow</code><span class="sig-paren">(</span><em class="sig-param">duration=0.03</em>, <em class="sig-param">step=0.01</em>, <em class="sig-param">start=0.0</em>, <em class="sig-param">end=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Sliding window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<em>float &gt; 0</em><em>, </em><em>optional</em>) – Window duration, in seconds. Default is 30 ms.</p></li>
<li><p><strong>step</strong> (<em>float &gt; 0</em><em>, </em><em>optional</em>) – Step between two consecutive position, in seconds. Default is 10 ms.</p></li>
<li><p><strong>start</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – First start position of window, in seconds. Default is 0.</p></li>
<li><p><strong>end</strong> (float &gt; <cite>start</cite>, optional) – Default is infinity (ie. window keeps sliding forever)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sw</span> <span class="o">=</span> <span class="n">SlidingWindow</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_range</span> <span class="o">==</span> <span class="n">sw</span><span class="o">.</span><span class="n">toFrameRange</span><span class="p">(</span><span class="n">sw</span><span class="o">.</span><span class="n">toSegment</span><span class="p">(</span><span class="o">*</span><span class="n">frame_range</span><span class="p">))</span>
<span class="gp">... </span><span class="kc">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_segment</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">toSegment</span><span class="p">(</span><span class="o">*</span><span class="n">sw</span><span class="o">.</span><span class="n">toFrameRange</span><span class="p">(</span><span class="n">segment</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">segment</span> <span class="o">&amp;</span> <span class="n">new_segment</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">sw</span><span class="o">.</span><span class="n">step</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sw</span> <span class="o">=</span> <span class="n">SlidingWindow</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sw</span><span class="p">))</span>
<span class="go">[ 00:00:00.000 --&gt;  00:00:00.030]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sw</span><span class="p">))</span>
<span class="go">[ 00:00:00.010 --&gt;  00:00:00.040]</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyannote.core.SlidingWindow.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">support: Union[pyannote.core.segment.Segment, Timeline], align_last: bool = False</em><span class="sig-paren">)</span> &#x2192; Iterable[pyannote.core.segment.Segment]<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Slide window over support</p>
<dl class="simple">
<dt>support<span class="classifier">Segment or Timeline</span></dt><dd><p>Support on which to slide the window.</p>
</dd>
<dt>align_last<span class="classifier">bool, optional</span></dt><dd><p>Yield a final segment so that it aligns exactly with end of support.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p><strong>chunk</strong> (<em>Segment</em>)</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">SlidingWindow</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">window</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
<span class="go">(3.0, 5.0)</span>
<span class="go">(4.0, 6.0)</span>
<span class="go">(5.0, 7.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">window</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">),</span> <span class="n">align_last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
<span class="go">(3.0, 5.0)</span>
<span class="go">(4.0, 6.0)</span>
<span class="go">(5.0, 7.0)</span>
<span class="go">(5.5, 7.5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">i: int</em><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Index of sliding window position</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>segment</strong> – Sliding window at ith position</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><code class="xref py py-class docutils literal notranslate"><span class="pre">Segment</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">duration=0.03</em>, <em class="sig-param">step=0.01</em>, <em class="sig-param">start=0.0</em>, <em class="sig-param">end=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.SlidingWindow<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Sliding window iterator</p>
<p>Use expression ‘for segment in sliding_window’</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">SlidingWindow</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
<span class="go">[ 00:00:00.000 --&gt;  00:00:00.030]</span>
<span class="go">[ 00:00:00.010 --&gt;  00:00:00.040]</span>
<span class="go">[ 00:00:00.020 --&gt;  00:00:00.050]</span>
<span class="go">[ 00:00:00.030 --&gt;  00:00:00.060]</span>
<span class="go">[ 00:00:00.040 --&gt;  00:00:00.070]</span>
<span class="go">[ 00:00:00.050 --&gt;  00:00:00.080]</span>
<span class="go">[ 00:00:00.060 --&gt;  00:00:00.090]</span>
<span class="go">[ 00:00:00.070 --&gt;  00:00:00.100]</span>
<span class="go">[ 00:00:00.080 --&gt;  00:00:00.110]</span>
<span class="go">[ 00:00:00.090 --&gt;  00:00:00.120]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of positions</p>
<p>Equivalent to len([segment for segment in window])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>length</strong> – Number of positions taken by the sliding window
(from start times to end times)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyannote.core.SlidingWindow.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#pyannote.core.SlidingWindow.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.closest_frame">
<code class="sig-name descname">closest_frame</code><span class="sig-paren">(</span><em class="sig-param">t: float</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.closest_frame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.closest_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Closest frame to timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Timestamp, in seconds.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – Index of frame whose middle is the closest to <cite>timestamp</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.SlidingWindow<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate sliding window</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.crop">
<code class="sig-name descname">crop</code><span class="sig-paren">(</span><em class="sig-param">focus: Union[pyannote.core.segment.Segment, Timeline], mode: typing_extensions.Literal['center', 'loose', 'strict'][center, loose, strict] = 'loose', fixed: Optional[float] = None, return_ranges: Optional[bool] = False</em><span class="sig-paren">)</span> &#x2192; Union[numpy.ndarray, List[List[int]]]<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.crop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop sliding window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>focus</strong> (<cite>Segment</cite> or <cite>Timeline</cite>) – </p></li>
<li><p><strong>mode</strong> (<em>{'strict'</em><em>, </em><em>'loose'</em><em>, </em><em>'center'}</em><em>, </em><em>optional</em>) – In ‘strict’ mode, only indices of segments fully included in
‘focus’ support are returned. In ‘loose’ mode, indices of any
intersecting segments are returned. In ‘center’ mode, first and
last positions are chosen to be the positions whose centers are the
closest to ‘focus’ start and end times. Defaults to ‘loose’.</p></li>
<li><p><strong>fixed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Overrides <cite>Segment</cite> ‘focus’ duration and ensures that the number of
returned frames is fixed (which might otherwise not be the case
because of rounding erros).</p></li>
<li><p><strong>return_ranges</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Return as list of ranges. Defaults to indices numpy array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>indices</strong> – Array of unique indices of matching segments</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array (or list of ranges)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.duration">
<em class="property">property </em><code class="sig-name descname">duration</code><a class="headerlink" href="#pyannote.core.SlidingWindow.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Sliding window duration in seconds.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.duration_to_samples">
<code class="sig-name descname">duration_to_samples</code><span class="sig-paren">(</span><em class="sig-param">duration: float</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.duration_to_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.duration_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns samples in duration</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.end">
<em class="property">property </em><code class="sig-name descname">end</code><a class="headerlink" href="#pyannote.core.SlidingWindow.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Sliding window end time in seconds.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.range_to_segment">
<code class="sig-name descname">range_to_segment</code><span class="sig-paren">(</span><em class="sig-param">i0: int</em>, <em class="sig-param">n: int</em><span class="sig-paren">)</span> &#x2192; pyannote.core.segment.Segment<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.range_to_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.range_to_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert 0-indexed frame range to segment</p>
<p>Each frame represents a unique segment of duration ‘step’, centered on
the middle of the frame.</p>
<p>The very first frame (i0 = 0) is the exception. It is extended to the
sliding window start time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Index of first frame</p></li>
<li><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of frames</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>segment</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment">Segment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">SlidingWindow</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">window</span><span class="o">.</span><span class="n">range_to_segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[ --&gt; ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.samples">
<code class="sig-name descname">samples</code><span class="sig-paren">(</span><em class="sig-param">from_duration: float</em>, <em class="sig-param">mode: typing_extensions.Literal['center'</em>, <em class="sig-param">'loose'</em>, <em class="sig-param">'strict'][center</em>, <em class="sig-param">loose</em>, <em class="sig-param">strict] = 'strict'</em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of frames</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_duration</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Duration in seconds.</p></li>
<li><p><strong>mode</strong> (<em>{'strict'</em><em>, </em><em>'loose'</em><em>, </em><em>'center'}</em>) – In ‘strict’ mode, computes the maximum number of consecutive frames
that can be fitted into a segment with duration <cite>from_duration</cite>.
In ‘loose’ mode, computes the maximum number of consecutive frames
intersecting a segment with duration <cite>from_duration</cite>.
In ‘center’ mode, computes the average number of consecutive frames
where the first one is centered on the start time and the last one
is centered on the end time of a segment with duration
<cite>from_duration</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.samples_to_duration">
<code class="sig-name descname">samples_to_duration</code><span class="sig-paren">(</span><em class="sig-param">n_samples: int</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.samples_to_duration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.samples_to_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns duration of samples</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.segment_to_range">
<code class="sig-name descname">segment_to_range</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span> &#x2192; Tuple[int, int]<a class="reference internal" href="_modules/pyannote/core/segment.html#SlidingWindow.segment_to_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindow.segment_to_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert segment to 0-indexed frame range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>segment</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>i0</strong> (<em>int</em>) – Index of first frame</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Number of frames</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">SlidingWindow</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">window</span><span class="o">.</span><span class="n">segment_to_range</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="go">i0, n</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.start">
<em class="property">property </em><code class="sig-name descname">start</code><a class="headerlink" href="#pyannote.core.SlidingWindow.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Sliding window start time in seconds.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindow.step">
<em class="property">property </em><code class="sig-name descname">step</code><a class="headerlink" href="#pyannote.core.SlidingWindow.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Sliding window step in seconds.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="slidingwindowfeature">
<h3>SlidingWindowFeature<a class="headerlink" href="#slidingwindowfeature" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyannote.core.SlidingWindowFeature">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.core.</code><code class="sig-name descname">SlidingWindowFeature</code><span class="sig-paren">(</span><em class="sig-param">data: numpy.ndarray</em>, <em class="sig-param">sliding_window: pyannote.core.segment.SlidingWindow</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Periodic feature vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>nSamples</em><em>, </em><em>nFeatures</em><em>) </em><em>numpy array</em>) – </p></li>
<li><p><strong>sliding_window</strong> (<a class="reference internal" href="#pyannote.core.SlidingWindow" title="pyannote.core.SlidingWindow"><em>SlidingWindow</em></a>) – </p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">i: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ith feature vector</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">data: numpy.ndarray</em>, <em class="sig-param">sliding_window: pyannote.core.segment.SlidingWindow</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of feature vectors</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">to: pyannote.core.feature.SlidingWindowFeature</em><span class="sig-paren">)</span> &#x2192; pyannote.core.feature.SlidingWindowFeature<a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align features by linear temporal interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>to</strong> (<a class="reference internal" href="#pyannote.core.SlidingWindowFeature" title="pyannote.core.SlidingWindowFeature"><em>SlidingWindowFeature</em></a>) – Features to align with.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>aligned</strong> – Aligned features</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyannote.core.SlidingWindowFeature" title="pyannote.core.SlidingWindowFeature">SlidingWindowFeature</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.crop">
<code class="sig-name descname">crop</code><span class="sig-paren">(</span><em class="sig-param">focus: Union[pyannote.core.segment.Segment, pyannote.core.timeline.Timeline], mode: typing_extensions.Literal['intersection', 'loose', 'strict'][intersection, loose, strict] = 'loose', fixed: Optional[float] = None, return_data: bool = True</em><span class="sig-paren">)</span> &#x2192; Union[numpy.ndarray, pyannote.core.feature.SlidingWindowFeature]<a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature.crop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract frames</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>focus</strong> (<a class="reference internal" href="#pyannote.core.Segment" title="pyannote.core.Segment"><em>Segment</em></a><em> or </em><a class="reference internal" href="#pyannote.core.Timeline" title="pyannote.core.Timeline"><em>Timeline</em></a>) – </p></li>
<li><p><strong>mode</strong> (<em>{'loose'</em><em>, </em><em>'strict'</em><em>, </em><em>'center'}</em><em>, </em><em>optional</em>) – In ‘strict’ mode, only frames fully included in ‘focus’ support are
returned. In ‘loose’ mode, any intersecting frames are returned. In
‘center’ mode, first and last frames are chosen to be the ones
whose centers are the closest to ‘focus’ start and end times.
Defaults to ‘loose’.</p></li>
<li><p><strong>fixed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Overrides <cite>Segment</cite> ‘focus’ duration and ensures that the number of
returned frames is fixed (which might otherwise not be the case
because of rounding errors).</p></li>
<li><p><strong>return_data</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Return a numpy array (default). For <cite>Segment</cite> ‘focus’, setting it
to False will return a <cite>SlidingWindowFeature</cite> instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>data</strong> – Frame features.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite> or <cite>SlidingWindowFeature</cite></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.core.SlidingWindow.crop" title="pyannote.core.SlidingWindow.crop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SlidingWindow.crop()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.dimension">
<em class="property">property </em><code class="sig-name descname">dimension</code><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of feature vectors</p>
</dd></dl>

<dl class="method">
<dt id="pyannote.core.SlidingWindowFeature.iterfeatures">
<code class="sig-name descname">iterfeatures</code><span class="sig-paren">(</span><em class="sig-param">window: Optional[bool] = False</em><span class="sig-paren">)</span> &#x2192; Iterator[Union[Tuple[numpy.ndarray, pyannote.core.segment.Segment], numpy.ndarray]]<a class="reference internal" href="_modules/pyannote/core/feature.html#SlidingWindowFeature.iterfeatures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.SlidingWindowFeature.iterfeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature vector iterator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – When True, yield both feature vector and corresponding window.
Default is to only yield feature vector</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pyannote.core.json">
<span id="serialization"></span><h2>Serialization<a class="headerlink" href="#module-pyannote.core.json" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyannote.core.json.dump">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">resource: Union[Segment, Timeline, SlidingWindowFeature, Annotation], fp: TextIO</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/json.html#dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resource</strong> (<cite>pyannote.core</cite> data structure) – Resource to serialize</p></li>
<li><p><strong>fp</strong> (<em>file</em>) – File in which <cite>resource</cite> serialization is written</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.json.dump_to">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">dump_to</code><span class="sig-paren">(</span><em class="sig-param">resource: Union[Segment, Timeline, SlidingWindowFeature, Annotation], path: Union[str, pathlib.Path]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/json.html#dump_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.dump_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resource</strong> (<cite>pyannote.core</cite> data structure) – Resource to serialize</p></li>
<li><p><strong>path</strong> (<em>string</em>) – Path to file in which <cite>resource</cite> serialization is written</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.json.dumps">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">dumps</code><span class="sig-paren">(</span><em class="sig-param">resource: Union[Segment, Timeline, SlidingWindowFeature, Annotation]</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/pyannote/core/json.html#dumps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize to string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>resource</strong> (<cite>pyannote.core</cite> data structure) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>serialization</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.json.load">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fp: TextIO</em><span class="sig-paren">)</span> &#x2192; Union[Segment, Timeline, SlidingWindowFeature, Annotation]<a class="reference internal" href="_modules/pyannote/core/json.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fp</strong> (<em>file</em>) – File containing serialized <cite>pyannote.core</cite> data structure</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>deserialized</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyannote.core</cite> data structure</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.json.load_from">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">load_from</code><span class="sig-paren">(</span><em class="sig-param">path: Union[str, pathlib.Path]</em><span class="sig-paren">)</span> &#x2192; Union[Segment, Timeline, SlidingWindowFeature, Annotation]<a class="reference internal" href="_modules/pyannote/core/json.html#load_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.load_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em><em> or </em><em>Path</em>) – Path to file containing serialized <cite>pyannote.core</cite> data structure</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>deserialized</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyannote.core</cite> data structure</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.json.loads">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">loads</code><span class="sig-paren">(</span><em class="sig-param">s: str</em><span class="sig-paren">)</span> &#x2192; Union[Segment, Timeline, SlidingWindowFeature, Annotation]<a class="reference internal" href="_modules/pyannote/core/json.html#loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong> (<em>string</em>) – String containing serialized <cite>pyannote.core</cite> data structure</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>deserialized</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyannote.core</cite> data structure</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.json.object_hook">
<code class="sig-prename descclassname">pyannote.core.json.</code><code class="sig-name descname">object_hook</code><span class="sig-paren">(</span><em class="sig-param">d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/json.html#object_hook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.json.object_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for deserialization</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;file.json&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">object_hook</span><span class="o">=</span><span class="n">object_hook</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyannote.core.notebook">
<span id="visualization"></span><h2>Visualization<a class="headerlink" href="#module-pyannote.core.notebook" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Visualization<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyannote.core.notebook.repr_annotation">
<code class="sig-prename descclassname">pyannote.core.notebook.</code><code class="sig-name descname">repr_annotation</code><span class="sig-paren">(</span><em class="sig-param">annotation: pyannote.core.annotation.Annotation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/notebook.html#repr_annotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.notebook.repr_annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Get <cite>png</cite> data for <cite>annotation</cite></p>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.notebook.repr_feature">
<code class="sig-prename descclassname">pyannote.core.notebook.</code><code class="sig-name descname">repr_feature</code><span class="sig-paren">(</span><em class="sig-param">feature: pyannote.core.feature.SlidingWindowFeature</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/notebook.html#repr_feature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.notebook.repr_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get <cite>png</cite> data for <cite>feature</cite></p>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.notebook.repr_segment">
<code class="sig-prename descclassname">pyannote.core.notebook.</code><code class="sig-name descname">repr_segment</code><span class="sig-paren">(</span><em class="sig-param">segment: pyannote.core.segment.Segment</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/notebook.html#repr_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.notebook.repr_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Get <cite>png</cite> data for <cite>segment</cite></p>
</dd></dl>

<dl class="function">
<dt id="pyannote.core.notebook.repr_timeline">
<code class="sig-prename descclassname">pyannote.core.notebook.</code><code class="sig-name descname">repr_timeline</code><span class="sig-paren">(</span><em class="sig-param">timeline: pyannote.core.timeline.Timeline</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/core/notebook.html#repr_timeline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.core.notebook.repr_timeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Get <cite>png</cite> data for <cite>timeline</cite></p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="changelog.html" class="btn btn-neutral float-right" title="Changelog" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="serialization.html" class="btn btn-neutral float-left" title="Serialization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, CNRS

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>